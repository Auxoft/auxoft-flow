#!/bin/bash


init() {
  require_git_repo
  require_af_initialized
  af_load_settings
  af_load_version
}


cmd_default() {
  usage
  exit 0
}


cmd_create() {
  parse_args "$@"

  RELEASE_VERSION=$VERSION_A.$(($VERSION_B + 1))
  if [[ "$VERSION_NAME" = "" ]]; then
    RELEASE_NAME="_"
  else
    RELEASE_NAME=$VERSION_NAME
  fi
  SPRINT_NUMBER=$VERSION_C

  question_short_version RELEASE_VERSION "release version" "$RELEASE_VERSION"
  question_version_name RELEASE_NAME "release version name (_ for empty)" "$RELEASE_NAME"

  RELEASE_BRANCH="$RELEASE_PREFIX$RELEASE_VERSION"
  RELEASE_TAG="$RELEASE_VERSION.0.0"
 
  # sanity checks
  require_clean_working_tree
  require_current_branch $MASTER_BRANCH
  require_branch_absent $RELEASE_BRANCH
  require_tag_absent $RELEASE_TAG

  
  mssg "pull from origin/$MASTER_BRANCH into $MASTER_BRANCH"

  git_do fetch origin
  git_do pull origin

  
  mssg "create release branch: $RELEASE_BRANCH"

  git_do checkout -b "$RELEASE_BRANCH"


  ./af hotfix start setup version
  

  NEW_VERSION="$RELEASE_VERSION.0.1"
  
  mssg "set release version in $RELEASE_BRANCH branch: $NEW_VERSION ($RELEASE_NAME)"

  af_update_version $NEW_VERSION $RELEASE_NAME
  af_load_version


  mssg "commit new version files to branch"

  git_do add -A
  git_do commit -a -m "### set release version: $NEW_VERSION"

  
  ./af hotfix finish -f


  mssg "create tag '$RELEASE_TAG'"

  git_do tag -a -m "### tag: $RELEASE_TAG" "$RELEASE_TAG" "$RELEASE_BRANCH" || \
    die "Tagging failed. Please run finish again to retry."


  mssg "push tag '$RELEASE_TAG' to origin"

  git_do push origin "$RELEASE_TAG" || \
    die "Pushing tag to origin failed. Please run finish again to retry."


  mssg "checkout to $MASTER_BRANCH"

  git_do checkout "$MASTER_BRANCH"


  MASTER_VERSION=$VERSION_A.$(($VERSION_B + 1))
  if [[ "$VERSION_NAME" = "" ]]; then
    MASTER_NAME="_"
  else
    MASTER_NAME=$VERSION_NAME
  fi

  question_short_version MASTER_VERSION "new master version" "$MASTER_VERSION"
  question_version_name MASTER_NAME "new master version name (_ for empty)" "$MASTER_NAME"

  MASTER_TAG="$MASTER_VERSION.$(($SPRINT_NUMBER + 1)).0"


  ./af feature start update version


  NEW_MASTER_VERSION="$MASTER_VERSION.$(($SPRINT_NUMBER + 1)).1"

  mssg "set new dev version in master branch: $NEW_MASTER_VERSION ($MASTER_NAME)"

  af_update_version $NEW_MASTER_VERSION $MASTER_NAME
  af_load_version

  mssg "commit new version files to branch"

  git_do add -A
  git_do commit -a -m "### set next dev version: $NEW_MASTER_VERSION"


  ./af feature finish -f


  mssg "create tag '$MASTER_TAG'"

  git_do tag -a -m "### tag: $MASTER_TAG" "$MASTER_TAG" "$MASTER_BRANCH" || \
    die "Tagging failed. Please run finish again to retry."

  mssg "push tag '$MASTER_TAG' to origin"

  git_do push origin "$MASTER_TAG" || \
    die "Pushing tag to origin failed. Please run finish again to retry."


  mssg "checkout to $RELEASE_BRANCH"

  git_do checkout "$RELEASE_BRANCH"
}


cmd_prebuild() {
  parse_args "$@"

  if [[ "$VERSION_C" == "0" ]]; then
    BUILD_BRANCH="$RCBUILD_PREFIX$VERSION"
  else
    BUILD_BRANCH="$PATCHBUILD_PREFIX$VERSION"
  fi
  RELEASE_BRANCH=`git_current_branch`

  # sanity checks
  require_clean_working_tree
  require_current_branch_prefix $RELEASE_PREFIX
  require_branch_absent $BUILD_BRANCH
  require_tag_absent "$VERSION"


  mssg "pull from origin/$RELEASE_BRANCH into $RELEASE_BRANCH"

  git_do fetch origin
  git_do pull origin


  if [[ "$VERSION_C" == "0" ]]; then
    mssg "create rcbuild branch: $NB_BRANCH"
  else
    mssg "create patchbuild branch: $NB_BRANCH"
  fi

  git_do checkout -b "$BUILD_BRANCH"
  af_load_version


  mssg "building"

  af_run_hook_file build "$VERSION_SHORT" "$VERSION_NAME" "$VERSION_TYPE" "$VERSION_LONG" || \
    die "There were build problem."


  NEW_VERSION=$VERSION_A.$VERSION_B.$VERSION_C.$(($VERSION_D + 1))

  mssg "increment version to $NEW_VERSION ($VERSION_NAME)"

  af_update_version $NEW_VERSION $VERSION_NAME


  mssg "commit new version files to branch"

  git_do add -A
  git_do commit -a -m "### update version to $NEW_VERSION"


  if has "$ORIGIN/$RELEASE_BRANCH" $(git_remote_branches); then
    require_branches_equal "$RELEASE_BRANCH" "$ORIGIN/$RELEASE_BRANCH"
  fi

  if ! git_is_branch_merged_into "$BUILD_BRANCH" "$RELEASE_BRANCH"; then
    mssg "checkout to $RELEASE_BRANCH"

    git_do checkout "$RELEASE_BRANCH" || \
      die "Could not check out $RELEASE_BRANCH."

    mssg "marge from $BUILD_BRANCH into $RELEASE_BRANCH"

    git_do merge --no-ff "$BUILD_BRANCH" -m "### marge from $BUILD_BRANCH into $RELEASE_BRANCH" || \
      die "There were merge conflicts."
  fi


  mssg "create tag '$VERSION'"

  git_do tag -a -m "### tag: $VERSION" "$VERSION" "$RELEASE_BRANCH" || \
    die "Tagging failed."


  mssg "push $RELEASE_BRANCH to origin"

  git_do push origin "$RELEASE_BRANCH" || \
    die "Pushing master to origin failed."

  
  mssg "push tag '$VERSION' to origin"

  git_do push origin "$VERSION" || \
    die "Pushing tag to origin failed."


  mssg "delete $BUILD_BRANCH"

  git_do branch -d "$BUILD_BRANCH"


  mssg "done"
}


cmd_build() {
  parse_args "$@"

  RELEASEBUILD_VERSION="$VERSION_A.$VERSION_B.$(($VERSION_C + 1))"
  NEW_RELEASE_TAG="$VERSION_A.$VERSION_B.$(($VERSION_C + 2)).0"

  RELEASEBUILD_BRANCH=$RELEASEBUILD_PREFIX$RELEASEBUILD_VERSION
  RELEASE_BRANCH=`git_current_branch`

  # sanity checks
  require_clean_working_tree
  require_current_branch_prefix $RELEASE_PREFIX
  require_branch_absent $RELEASEBUILD_BRANCH
  require_tag_absent "$RELEASEBUILD_VERSION"
  require_tag_absent "$NEW_RELEASE_TAG"


  mssg "pull from origin/$RELEASE_BRANCH into $RELEASE_BRANCH"

  git_do fetch origin
  git_do pull origin


  mssg "create releasebuild branch: $RELEASEBUILD_BRANCH"

  git_do checkout -b "$RELEASEBUILD_BRANCH"


  mssg "set version to $RELEASEBUILD_VERSION ($VERSION_NAME)"

  af_update_version $RELEASEBUILD_VERSION $VERSION_NAME
  af_load_version


  mssg "building"

  af_run_hook_file build "$VERSION_SHORT" "$VERSION_NAME" "$VERSION_TYPE" "$VERSION_LONG" || \
    die "There were build problem."


  mssg "commit new version files to branch"

  git_do add -A
  git_do commit -a -m "### update version to $RELEASEBUILD_VERSION"


  mssg "create tag '$RELEASEBUILD_VERSION'"

  git_do tag -a -m "### tag: $RELEASEBUILD_VERSION" "$RELEASEBUILD_VERSION" "$RELEASE_BRANCH" || \
    die "Tagging failed. Please run finish again to retry."


  mssg "push tag '$RELEASEBUILD_VERSION' to origin"

  git_do push origin "$RELEASEBUILD_VERSION" || \
    die "Pushing tag to origin failed. Please run finish again to retry."


  NEW_VERSION="$VERSION_A.$VERSION_B.$(($VERSION_C + 1)).1"
  
  mssg "increment version to $NEW_VERSION ($VERSION_NAME)"

  af_update_version $NEW_VERSION $VERSION_NAME
  af_load_version


  mssg "commit new version files to branch"

  git_do add -A
  git_do commit -a -m "### update release version: $NEW_VERSION"


  if has "$ORIGIN/$RELEASE_BRANCH" $(git_remote_branches); then
    require_branches_equal "$RELEASE_BRANCH" "$ORIGIN/$RELEASE_BRANCH"
  fi

  if ! git_is_branch_merged_into "$RELEASEBUILD_BRANCH" "$RELEASE_BRANCH"; then
    mssg "checkout to $RELEASE_BRANCH"

    git_do checkout "$RELEASE_BRANCH" || \
      die "Could not check out $RELEASE_BRANCH."

    mssg "marge from $RELEASEBUILD_BRANCH into $RELEASE_BRANCH"

    git_do merge --no-ff "$RELEASEBUILD_BRANCH" -m "### marge from $RELEASEBUILD_BRANCH into $RELEASE_BRANCH" || \
      die "There were merge conflicts."
  fi


  mssg "create tag '$NEW_RELEASE_TAG'"

  git_do tag -a -m "### tag: $NEW_RELEASE_TAG" "$NEW_RELEASE_TAG" "$RELEASE_BRANCH" || \
    die "Tagging failed."

  
  mssg "push $RELEASE_BRANCH to origin"

  git_do push origin "$RELEASE_BRANCH" || \
    die "Pushing master to origin failed."


  mssg "push tag '$NEW_RELEASE_TAG' to origin"

  git_do push origin "$NEW_RELEASE_TAG" || \
    die "Pushing tag to origin failed."


  mssg "delete $RELEASEBUILD_BRANCH"

  git_do branch -d "$RELEASEBUILD_BRANCH"


  mssg "done"
}

cmd_list() {
  parse_args "$@"


  local_branches=( `git_local_branches` )
  current_branch=( `git_current_branch` )

  printed="NO"
  for branch in ${local_branches[@]}; do
    if [[ $branch == $RELEASE_PREFIX* ]] ; then

      if [[ $branch == $current_branch ]] ; then
        clr_green "* $branch"
      else
        clr_blue "  $branch"
      fi

      printed="YES"
    fi
  done

  if [[ $printed == "NO" ]] ; then
    clr_brown "  nothing"
  fi
}


usage_init() {
  FLAGS_HELP=`cat << EndOfMessage
USAGE: af release create [-s] [-g] [-h]
       af release prebuild [-s] [-g] [-h]
       af release build [-s] [-g] [-h]
       af release list [-s] [-g] [-h]

subcommans:
  create          Create release branch (run on master branch)."
  prebuild        Create rcbuild or patchbuild (run on release-*.* branch)."
  build           Create release build (run on release-*.* branch)."
  list            Print all release branches
 
EndOfMessage`
}

